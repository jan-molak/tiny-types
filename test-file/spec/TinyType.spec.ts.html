<!DOCTYPE html><html><head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">spec/TinyType.spec.ts | tiny-types</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-KCJMHPK');</script><meta name="google-site-verification" content="mpKDC5KqgH5qYaWKMHWJoZn7iFGd4EYF9CtYYRSexYA"><link rel="stylesheet" href="./inject/css/0-custom.css"><meta name="description" content="A tiny library that brings Tiny Types to JavaScript and TypeScript"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="tiny-types"><meta property="twitter:description" content="A tiny library that brings Tiny Types to JavaScript and TypeScript"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/jan-molak/tiny-types.git"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/TinyType.ts~TinyType.html">TinyType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-TinyTypeOf">TinyTypeOf</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-ensure">ensure</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-match">match</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-check">check</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#objects">objects</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-deprecated">deprecated</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isRecord">isRecord</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#predicates">predicates</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/predicates/Predicate.ts~Failure.html">Failure</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/predicates/Predicate.ts~Predicate.html">Predicate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/predicates/Predicate.ts~Result.html">Result</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/predicates/Predicate.ts~Success.html">Success</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-and">and</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-endsWith">endsWith</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-hasLengthOf">hasLengthOf</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isArray">isArray</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isBoolean">isBoolean</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isDefined">isDefined</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isEqualTo">isEqualTo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isFunction">isFunction</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isGreaterThan">isGreaterThan</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isGreaterThanOrEqualTo">isGreaterThanOrEqualTo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isInRange">isInRange</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isInstanceOf">isInstanceOf</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isInteger">isInteger</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isLessThan">isLessThan</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isLessThanOrEqualTo">isLessThanOrEqualTo</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isNotBlank">isNotBlank</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isNumber">isNumber</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isOneOf">isOneOf</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isPlainObject">isPlainObject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-isString">isString</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-matches">matches</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-or">or</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-property">property</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-startsWith">startsWith</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">spec/TinyType.spec.ts</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import &apos;mocha&apos;;

import { given } from &apos;mocha-testdata&apos;;

import { JSONObject, JSONPrimitive, TinyType, TinyTypeOf } from &apos;../src&apos;;
import { expect } from &apos;./expect&apos;;

/** @test {TinyType} */
describe(&apos;TinyType&apos;, () =&gt; {

    describe(&apos;wrapping a single value&apos;, () =&gt; {

        /** @test {TinyType} */
        describe(&apos;definition&apos;, () =&gt; {

            /** @test {TinyTypeOf} */
            it(&apos;can be a one-liner for TinyTypes representing a single value&apos;, () =&gt; {
                class FirstName extends TinyTypeOf&lt;string&gt;() {
                }

                const firstName = new FirstName(&apos;Jan&apos;);

                expect(firstName.value).to.equal(&apos;Jan&apos;);
                expect(firstName).to.be.instanceOf(FirstName);
                expect(firstName).to.be.instanceOf(TinyType);
                expect(firstName.constructor.name).to.equal(&apos;FirstName&apos;);
                expect(firstName.toString()).to.equal(&apos;FirstName(value=Jan)&apos;);
            });

            /** @test {TinyTypeOf} */
            it(&apos;prevents null and undefined when the single-line definition style is used&apos;, () =&gt; {
                class FirstName extends TinyTypeOf&lt;string&gt;() {
                }

                expect(() =&gt; new FirstName(null as any)).to.throw(&apos;FirstName should be defined&apos;);
                expect(() =&gt; new FirstName(undefined as any)).to.throw(&apos;FirstName should be defined&apos;);
            });

            /**
             * @test {TinyType}
             * @test {TinyTypeOf}
             */
            it(&apos;needs to extend the TinyType for types with more than one value&apos;, () =&gt; {
                class FirstName extends TinyTypeOf&lt;string&gt;() {
                }

                class LastName extends TinyTypeOf&lt;string&gt;() {
                }

                class FullName extends TinyType {
                    constructor(
                        public readonly firstName: FirstName,
                        public readonly lastName: LastName,
                    ) {
                        super();
                    }
                }

                const fullName = new FullName(new FirstName(&apos;Jan&apos;), new LastName(&apos;Molak&apos;));

                expect(fullName.firstName.value).to.equal(&apos;Jan&apos;);
                expect(fullName.lastName.value).to.equal(&apos;Molak&apos;);
                expect(fullName).to.be.instanceOf(FullName);
                expect(fullName).to.be.instanceOf(FullName);
                expect(fullName.constructor.name).to.equal(&apos;FullName&apos;);
                expect(fullName.toString()).to.equal(&apos;FullName(firstName=FirstName(value=Jan), lastName=LastName(value=Molak))&apos;);
            });

            /**
             * @test {TinyType}
             * @test {TinyTypeOf}
             */
            it(&apos;can be mixed and matched&apos;, () =&gt; {
                const now = new Date(Date.UTC(2018, 2, 12, 0, 30, 0));

                class UserName extends TinyTypeOf&lt;string&gt;() {
                }

                class Timestamp extends TinyTypeOf&lt;Date&gt;() {
                    toString() {
                        return `Timestamp(value=${ this.value.toISOString() })`;
                    }
                }

                abstract class DomainEvent extends TinyTypeOf&lt;Timestamp&gt;() {
                }

                class AccountCreated extends DomainEvent {
                    constructor(public readonly username: UserName, timestamp: Timestamp) {
                        super(timestamp);
                    }
                }

                const event = new AccountCreated(new UserName(&apos;jan-molak&apos;), new Timestamp(now));

                expect(event.toString()).to.equal(
                    &apos;AccountCreated(username=UserName(value=jan-molak), value=Timestamp(value=2018-03-12T00:30:00.000Z))&apos;,
                );
            });
        });

        /** @test {TinyType#toString} */
        describe(&apos;::toString&apos;, () =&gt; {
            class Area extends TinyTypeOf&lt;string&gt;() {
            }

            class District extends TinyTypeOf&lt;number&gt;() {
            }

            class Sector extends TinyTypeOf&lt;number&gt;() {
            }

            class Unit extends TinyTypeOf&lt;string&gt;() {
            }

            class Postcode extends TinyType {
                constructor(public readonly area: Area,
                    public readonly district: District,
                    public readonly sector: Sector,
                    public readonly unit: Unit,
                ) {
                    super();
                }
            }

            it(&apos;mentions the class and its properties&apos;, () =&gt; {
                const area = new Area(&apos;GU&apos;);

                expect(area.toString()).to.equal(&apos;Area(value=GU)&apos;);
            });

            it(&apos;mentions the class and its fields, but not the methods&apos;, () =&gt; {
                class Person extends TinyType {
                    constructor(public readonly name: string) {
                        super();
                    }

                    rename = (newName: string) =&gt; new Person(newName);
                }

                const p = new Person(&apos;James&apos;);

                expect(p.toString())
                    .to.equal(&apos;Person(name=James)&apos;);
            });

            it(&apos;only cares about the fields, not the methods&apos;, () =&gt; {
                const postcode = new Postcode(
                    new Area(&apos;GU&apos;),
                    new District(15),
                    new Sector(9),
                    new Unit(&apos;NZ&apos;),
                );

                expect(postcode.toString())
                    .to.equal(&apos;Postcode(area=Area(value=GU), district=District(value=15), sector=Sector(value=9), unit=Unit(value=NZ))&apos;);
            });

            it(&apos;prints the array-type properties&apos;, () =&gt; {
                class Name extends TinyTypeOf&lt;string&gt;() {
                }

                class Names extends TinyTypeOf&lt;Name[]&gt;() {
                }

                const names = new Names([new Name(&apos;Alice&apos;), new Name(&apos;Bob&apos;)]);

                expect(names.toString())
                    .to.equal(&apos;Names(value=Array(Name(value=Alice), Name(value=Bob)))&apos;);
            });

            it(&apos;prints the object-type properties&apos;, () =&gt; {
                class Dictionary extends TinyTypeOf&lt;{ [key: string]: string }&gt;() {
                }

                const dictionary = new Dictionary({ greeting: &apos;Hello&apos;, subject: &apos;World&apos; });

                expect(dictionary.toString())
                    .to.equal(&apos;Dictionary(value=Object(greeting=Hello, subject=World))&apos;);
            });
        });

        /** @test {TinyType#toJSON} */
        describe(&apos;serialisation&apos;, () =&gt; {

            class FirstName extends TinyTypeOf&lt;string&gt;() {
            }

            class LastName extends TinyTypeOf&lt;string&gt;() {
            }

            class Age extends TinyTypeOf&lt;number&gt;() {
            }

            class Person extends TinyType {
                constructor(public readonly firstName: FirstName,
                    public readonly lastName: LastName,
                    public readonly age: Age,
                ) {
                    super();
                }
            }

            class People extends TinyTypeOf&lt;Person[]&gt;() {
            }

            describe(&apos;::toJSON&apos;, () =&gt; {

                given&lt;TinyType &amp; { value: any }&gt;(
                    new FirstName(&apos;Bruce&apos;),
                    new Age(55),
                ).it(&apos;should serialise a single-value TinyType to just its value&apos;, input =&gt; {
                    expect(input.toJSON()).to.equal(input.value);
                });

                it(&apos;should serialise a complex TinyType recursively&apos;, () =&gt; {

                    const person = new Person(new FirstName(&apos;Bruce&apos;), new LastName(&apos;Smith&apos;), new Age(55));

                    expect(person.toJSON()).to.deep.equal({
                        firstName: &apos;Bruce&apos;,
                        lastName: &apos;Smith&apos;,
                        age: 55,
                    });
                });

                it(`should serialise an array recursively`, () =&gt; {
                    const people = new People([
                        new Person(new FirstName(&apos;Alice&apos;), new LastName(&apos;Jones&apos;), new Age(62)),
                        new Person(new FirstName(&apos;Bruce&apos;), new LastName(&apos;Smith&apos;), new Age(55)),
                    ]);

                    expect(people.toJSON()).to.deep.equal([{
                        firstName: &apos;Alice&apos;,
                        lastName: &apos;Jones&apos;,
                        age: 62,
                    }, {
                        firstName: &apos;Bruce&apos;,
                        lastName: &apos;Smith&apos;,
                        age: 55,
                    }]);
                });

                it(`should serialise a plain-old JavaScript object`, () =&gt; {
                    class Parameters extends TinyTypeOf&lt;{ [parameter: string]: string }&gt;() {
                    }

                    const parameters = new Parameters({
                        env: &apos;prod&apos;,
                    });

                    expect(parameters.toJSON()).to.deep.equal({
                        env: &apos;prod&apos;,
                    });
                });

                it(`should serialise Map as object`, () =&gt; {
                    class Notes extends TinyTypeOf&lt;Map&lt;string, any&gt;&gt;() {
                    }

                    const parameters = new Notes(new Map(Object.entries({
                        stringEntry: &apos;prod&apos;,
                        numberEntry: 42,
                        objectEntry: { key: &apos;value&apos; },
                    })));

                    expect(parameters.toJSON()).to.deep.equal({
                        stringEntry: &apos;prod&apos;,
                        numberEntry: 42,
                        objectEntry: { key: &apos;value&apos; },
                    });
                });

                it(`should serialise a Set as Array`, () =&gt; {
                    class Notes extends TinyTypeOf&lt;Set&lt;string&gt;&gt;() {
                    }

                    const parameters = new Notes(new Set([&apos;apples&apos;, &apos;bananas&apos;, &apos;cucumbers&apos;]));

                    expect(parameters.toJSON()).to.deep.equal([&apos;apples&apos;, &apos;bananas&apos;, &apos;cucumbers&apos;]);
                });

                it(&apos;should serialise a plain-old JavaScript object with nested complex types recursively&apos;, () =&gt; {
                    interface NotesType {
                        authCredentials: {
                            username: string;
                            password: string;
                        },
                        names:  Set&lt;FirstName&gt;;
                        age:    Map&lt;FirstName, Age&gt;;
                    }

                    class Notes extends TinyTypeOf&lt;NotesType&gt;() {
                    }

                    const
                        alice = new FirstName(&apos;Alice&apos;),
                        bob = new FirstName(&apos;Bob&apos;),
                        cindy = new FirstName(&apos;Cindy&apos;);

                    const names = new Set&lt;FirstName&gt;([ alice, bob, cindy ]);
                    const age = new Map&lt;FirstName, Age&gt;()
                        .set(alice, new Age(23))
                        .set(bob, new Age(42))
                        .set(cindy, new Age(67));

                    const notes = new Notes({
                        authCredentials: {
                            username: &apos;Alice&apos;,
                            password: &apos;P@ssw0rd!&apos;,
                        },
                        names,
                        age
                    });

                    expect(notes.toJSON()).to.deep.equal({
                        authCredentials: {
                            username: &apos;Alice&apos;,
                            password: &apos;P@ssw0rd!&apos;,
                        },
                        names: [ &apos;Alice&apos;, &apos;Bob&apos;, &apos;Cindy&apos; ],
                        age: {
                            Alice: 23,
                            Bob: 42,
                            Cindy: 67,
                        }
                    });
                });

                it(&apos;should serialise null and undefined&apos;, () =&gt; {
                    interface NotesType {
                        nullValue: any;
                        undefinedValue: any;
                    }

                    class Notes extends TinyTypeOf&lt;NotesType&gt;() {
                    }

                    const notes = new Notes({
                        nullValue: null,
                        undefinedValue: undefined,
                    });

                    expect(notes.toJSON()).to.deep.equal({
                        nullValue: null,
                        undefinedValue: undefined,
                    });
                });

                it(`should JSON.stringify any object that can&apos;t be represented in a more sensible way`, () =&gt; {
                    class TT extends TinyTypeOf&lt;number&gt;() {
                    }

                    const tt = new TT(Number.NaN);

                    expect(tt.toJSON()).to.equal(&apos;null&apos;);
                });
            });
        });

        /** @test {TinyType} */
        describe(&apos;de-serialisation&apos;, () =&gt; {

            type SerialisedFirstName = string &amp; JSONPrimitive;

            class FirstName extends TinyTypeOf&lt;string&gt;() {
                static fromJSON = (v: SerialisedFirstName) =&gt; new FirstName(v);

                toJSON(): SerialisedFirstName {
                    return super.toJSON() as SerialisedFirstName;
                }
            }

            type SerialisedLastName = string &amp; JSONPrimitive;

            class LastName extends TinyTypeOf&lt;string&gt;() {
                static fromJSON = (v: SerialisedLastName) =&gt; new LastName(v);

                toJSON(): SerialisedLastName {
                    return super.toJSON() as SerialisedLastName;
                }
            }

            type SerialisedAge = number &amp; JSONPrimitive;

            class Age extends TinyTypeOf&lt;number&gt;() {
                static fromJSON = (v: SerialisedAge) =&gt; new Age(v);

                toJSON(): SerialisedAge {
                    return super.toJSON() as SerialisedAge;
                }
            }

            interface SerialisedPerson extends JSONObject {
                firstName: SerialisedFirstName;
                lastName: SerialisedLastName;
                age: SerialisedAge;
            }

            class Person extends TinyType {
                static fromJSON = (v: SerialisedPerson) =&gt; new Person(
                    FirstName.fromJSON(v.firstName),
                    LastName.fromJSON(v.lastName),
                    Age.fromJSON(v.age),
                );

                constructor(public readonly firstName: FirstName,
                    public readonly lastName: LastName,
                    public readonly age: Age,
                ) {
                    super();
                }

                toJSON(): SerialisedPerson {
                    return super.toJSON() as SerialisedPerson;
                }
            }

            it(&apos;custom fromJSON can de-serialise a serialised single-value TinyType&apos;, () =&gt; {
                const firstName = new FirstName(&apos;Jan&apos;);

                // tslint:disable-next-line:no-unused-expression
                expect(FirstName.fromJSON(firstName.toJSON()).equals(firstName)).to.be.true;
            });

            it(&apos;custom fromJSON can recursively de-serialise a serialised complex TinyType&apos;, () =&gt; {
                const person = new Person(new FirstName(&apos;Bruce&apos;), new LastName(&apos;Smith&apos;), new Age(55));

                // tslint:disable-next-line:no-unused-expression
                expect(Person.fromJSON(person.toJSON()).equals(person)).to.be.true;
            });
        });
    });
});
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>


</body></html>